<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Babylon.js Animation Example</title>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  <script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>




  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL"
    crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
    integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous" />
  <link rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap-select/1.13.18/css/bootstrap-select.min.css" />

  <style>
    #renderCanvas {
      width: 100%;
      height: 100%;
      touch-action: none;
    }
  </style>
</head>

<body>
  <!-- Bootstrap Modal -->
  <div class="modal fade" id="errorModal" tabindex="-1" role="dialog" aria-labelledby="errorModalLabel"
    aria-hidden="true">
    <div class="modal-dialog modal-xl" role="document">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="errorModalLabel">Error</h5>
          <button type="button" class="close" data-dismiss="modal" aria-label="Close">
            <span aria-hidden="true">&times;</span>
          </button>
        </div>
        <div class="modal-body" id="errorModalBody">
          <!-- Error message goes here -->
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-dismiss="modal">
            Close
          </button>
        </div>
      </div>
    </div>
  </div>


  <div class="modal fade" id="signBuilder" tabindex="-1" aria-labelledby="errorModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="errorModalLabel">Add Gloss</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <input type="text" id="searchInput" class="form-control" placeholder="Search for glos" oninput="searchGlos()">
          <div id="glosContainer" class="mt-3"></div>
          <div id="selectedGlos" class="mt-3"></div>

        </div>
        <div class="modal-footer">
          <!-- add checkbox to enable recording -->
          Record and save the sentence? <input type="checkbox" id="recordCheckbox" class="form-check-input"
            onclick="toggleRecording()">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
          <button type="button" class="btn btn-warning" onclick="cleanSentence()">Clean Sentence</button>
          <button type="button" class="btn btn-primary" onclick="handleGlosses()">Create Sentence</button>

        </div>
      </div>
    </div>
  </div>

  <div class="modal fade" id="glossModal" tabindex="-1" role="dialog" aria-labelledby="glossModalLabel"
    aria-hidden="true">
    <div class="modal-dialog">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="glossModalLabel">Enter Gloss</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <input type="text" id="glossInput" class="form-control" placeholder="Enter gloss"
            value="http://localhost:8080/MeshesAndAnims/HeadTwist3NPM.glb">
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
          <button type="button" class="btn btn-primary"
            onclick="stopLoadAndPlayAnimation(document.getElementById('glossInput').value)">Submit</button>
        </div>
      </div>
    </div>
  </div>


  <canvas id="renderCanvas"></canvas>

  <!-- Define clickable buttons for user to interact with the website -->
  <button onclick="animationSequencing(true); recordingMethod=''">Load Animation sequence and Record them</button>
  <button onclick="animationSequencing()">Load Animation Sequence and play them</button>
  <button onclick="signBuilder()">Sign Builder</button>
  <button onclick="signFetcher()">New Gloss</button>
  <button onclick="addAngle(10)">test add 10 degrees</button>
  <button onclick="getAngle()">get angle</button>
  <button onclick="stopAnimsAndReturnToRest()">stopAnims return to rest</button>
  <button onclick="testAndFetch()">test button</button>
  <button onclick="testMove(EngineController.loadedMesh.root)">test move</button>


  <!-- Fetch all scripts that we use -->
  <script src="SceneAndMeshLoader.js"></script>
  <script src="animFetchAndDestroy.js"></script>
  <script src="playAnims.js"></script>
  <script src="ScreenRecorder.js"></script>
  <script src="signCollectLoader.js"></script>
  <script src="cameraController.js"></script>
  <script src="noiseGenerator.js"></script>
  <script src="signBuilder.js"></script>
  <script src="retargetAnims.js"></script>
  <script src="initialize.js"></script>
  <script>
    //                                                                                          PINEAPPLE 
    // 🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍🍍
    //                                                                                   GOMER, JARI, OLINE, LISA
    //                                                                                      🥑🥑🥑🥑🥑🥑🥑🥑

    /*
      Setup Dir, URL, engine, and other variables
    */
    // Engine vars
    var engine;
    var scene;
    var canvas;
    var loadedMesh;

    // Directory vars (differentiated between a path for animations and a path for meshes)
    // const basePath = "http://localhost:8080/MeshesAndAnims/olines_anims/";
    // const basePath = "/gebarenoverleg_media/fbx/"; 
    let basePath = "https://leffe.science.uva.nl:8043/gebarenoverleg_media/fbx/";
    // let basePath = "http://localhost:8080/MeshesAndAnims/";
    let basePathMesh = "http://localhost:8080/MeshesAndAnims/";


    if (window.location.hostname === "leffe.science.uva.nl") {
      basePath = "https://leffe.science.uva.nl:8043/gebarenoverleg_media/fbx/";
      basePathMesh = "./MeshesAndAnims/";
    }

    // const basePathMesh = "http://localhost:8080/MeshesAndAnims/Nemu/"
    // const basePathMesh = "./MeshesAndAnims/"

    // Animation vars
    var animAsset;
    // var animationGroupFrom;
    // var animationGroupTo;
    var zinArray = []
    var recordingMethod;
    var recordingFile;
    let keepAnimating = true;
    // let continueLoop = true;
    var animations = []

    // URL params for gloss, thema, cameraAngle, movingCamera (followed by an example comment)
    var urlParams = new URLSearchParams(window.location.search);
    var glos = urlParams.get("glos"); // glos=AAP
    var thema = urlParams.get("thema"); // thema=oline
    var cameraAngle = urlParams.get("cameraAngle"); // cameraAngle=270
    var cameraAngleBeta = urlParams.get("cameraAngleBeta"); // cameraAngle=270
    var movingCamera = urlParams.get("movingCamera"); // movingCamera=1, if you want camera to keep moving
    var boneLock = urlParams.get("boneLock"); // boneLock=4, 0 == hip, 4 == neck, etc.
    var play = urlParams.get("play"); // play=no, if you don't want to play the animation
    var zin = urlParams.get("zin") // IK,BEN,GOMER
    var limit = urlParams.get("limit") // limit=50, if you want to limit the amount of animations
    var gltf = urlParams.get("gltf") // gltf=1, if you want to load animations with gltf extension
    var local = urlParams.get("local") // local=1, if you want to load animations from local folder
    var blending = urlParams.get("blending") // blending=1, if you want to blend animations
    var debug = urlParams.get("debug") // debug=1, if you want to see debug terminal
    var lockRot = urlParams.get("lockRot") // debug=1, if you want to see debug terminal

    /*
      Initialize the engine, scene, canvas, and mesh after the DOM has loaded
      Then play the animation if the play parameter is not set to "no"
    */
    document.addEventListener("DOMContentLoaded", function () {
      // Set the parameters (im not sure if javascript is pass by reference or value, so i return the values and set them again)
      // [local, play, limit, glos, zin, gltf, animations] = setParams(local, play, limit, glos, zin, gltf, animations);
      ParamsManager.setParams(local, play, limit, glos, zin, gltf, debug, lockRot);


      canvas = document.getElementById("renderCanvas");
      if (!canvas) {
        throw new Error("The canvas element is not available.");
      }

      // Load the scene and mesh. Then initialize the animations
      initialize(scene, engine, canvas, basePath, basePathMesh, loadedMesh, cameraAngle, cameraAngleBeta, movingCamera, boneLock, blending)
        .then(([initializedScene, initializedEngine, initializedLoadedMesh]) => {
          scene = initializedScene;
          engine = initializedEngine;
          loadedMesh = initializedLoadedMesh;

          EngineController.engine = engine;
          EngineController.scene = scene;
          EngineController.loadedMesh = loadedMesh;
          // EngineController.setScene(scene);
          // EngineController.setLoadedMesh(loadedMesh);

          removeAnims(scene, loadedMesh);
          removeAnims(scene, scene);
          initAnims();
        })
        .catch(error => {
          console.error('Failed to initialize:', error);
        });

      function initAnims() {
        // Load the animation
        getAnims(basePath, scene, loadedMesh, ParamsManager.glos, ParamsManager.gltf)
          .then(anim => {
            animAsset = anim;
            animAsset.animationGroups.push(retargetAnimWithBlendshapes(loadedMesh, animAsset, "anim"));

            keepOnlyAnimationGroup(scene, animAsset, loadedMesh, "anim");

            if (ParamsManager.play != "no") {
              playLoadedAnims(scene, loadedMesh);
            }
          })
          .catch(error => {
            console.error('Failed to load animations:', error);
          });
      }
    });


    /*
      Functions for buttons start here.
    */
    async function testAndFetch() {
      console.error("test button pressed");
      // const glasses = await loadAssetMesh(scene, basePathMesh, filename = "glassesGuyNew.glb");

      // EngineController.loadedMesh.retargetMappings.push({ "glassesGuyNew": calcProportionInfo(glasses.skeletons[0], EngineController.loadedMesh.skeletons[0]) });
      console.log(EngineController.loadedMesh.retargetMappings);

      // Todo: add animation from glassesGuyNew and apply it to loadedMesh with a retarget using retargetMappings
      getAnims(basePath, scene, EngineController.loadedMesh, "ALLEMAAL-A", ParamsManager.gltf)
        .then(z => {
          const newAnim = retargetAnimWithBlendshapes(EngineController.loadedMesh, z, "z");
          z.animationGroups.push(newAnim);
          EngineController.loadedMesh.fetched.animationGroups.push(newAnim);
          console.log(EngineController.loadedMesh.fetched);
          keepOnlyAnimationGroup(scene, z, EngineController.loadedMesh, "z");

          if (ParamsManager.play != "no") {
            playAnims(scene, EngineController.loadedMesh, 0);
          }
        })
        .catch(error => {
          console.error('Failed to load animations:', error);
        });
    }

    function testMove(obj, amount = -9e-8) {
      obj.position.y += amount;
    }

    function stopAnimsAndReturnToRest() {
      stopAnims(EngineController.scene, EngineController.loadedMesh);

      // Remove the currently loaded animation
      removeAnims(EngineController.scene, EngineController.loadedMesh);
      removeAnims(EngineController.scene, scene);

      EngineController.loadedMesh.skeletons[0].returnToRest();
    }

    // Function to play animations sequentially
    async function animationSequencing(recording = false, keepPlaying = true, frame) {
      // Stop any ongoing animation loops
      // continueLoop = false
      AnimationSequencer.stop();
      AnimationSequencer.setSequencing(true);

      if (frame == "blend") {
        //we want to adjust frames
        AnimationSequencer.setFrom(60);
        AnimationSequencer.setTo(60);
      }
      else {
        //we want to adjust frames
        AnimationSequencer.setFrom(30);
        AnimationSequencer.setTo(30);
      }
      keepAnimating = false;

      // waiting modal
      await showModal();
      // Stop any current animations
      if (stopAnims(EngineController.scene, EngineController.loadedMesh)) {
        // check if animation is stopped
        if (removeAnims(EngineController.scene, EngineController.loadedMesh) && removeAnims(EngineController.scene, EngineController.scene)) {
          // await hideModal();
          // await new Promise(resolve => setTimeout(resolve, 3000));
          console.log("play animations, recording=" + recording);
          await AnimationSequencer.start(basePath, EngineController.scene, EngineController.loadedMesh, ParamsManager.animations, recording = recording);
        }
      }
    }

    // Function to show modal and wait for it to be shown
    function showModal() {
      return new Promise((resolve) => {
        $('#errorModal').modal('show').on('shown.bs.modal', () => {
          $('#errorModalLabel').text("Please wait, loading Anims. First time always takes longer");
          resolve();
        });
      });
    }

    // Function to hide modal and wait for it to be hidden
    function hideModal() {
      return new Promise((resolve) => {
        $('#errorModal').modal('hide').on('hidden.bs.modal', () => {
          resolve();
        });
      });
    }
  </script>
</body>

</html>